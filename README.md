# leetCode_codes
this a project for me to practice my code skill



LeetCode 题目总结/分类
马孔多 马孔多 2014-02-14 10:19:33
注：此分类仅供大概参考，没有精雕细琢。有不同意见欢迎评论~
欢迎参考我的leetcode代码

利用堆栈：
http://oj.leetcode.com/problems/evaluate-reverse-polish-notation/
http://oj.leetcode.com/problems/longest-valid-parentheses/ （也可以用一维数组，贪心）
http://oj.leetcode.com/problems/valid-parentheses/
http://oj.leetcode.com/problems/largest-rectangle-in-histogram/
特别注意细节：http://oj.leetcode.com/problems/trapping-rain-water/

多种数据结构：
http://oj.leetcode.com/problems/lru-cache/
http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/ (注意遍历方法）
HASH：http://oj.leetcode.com/problems/longest-consecutive-sequence/

简单编程：
http://oj.leetcode.com/problems/longest-common-prefix/
http://oj.leetcode.com/problems/string-to-integer-atoi/  (分析，控制语句）

排序 & 查找：
二分查找：http://oj.leetcode.com/problems/search-a-2d-matrix/
二分查找进阶：http://oj.leetcode.com/problems/search-for-a-range/
二分查找应用：http://oj.leetcode.com/problems/sqrtx/
二分查找应用：http://oj.leetcode.com/problems/search-insert-position/
二分查找变种：http://oj.leetcode.com/problems/search-in-rotated-sorted-array/
二分查找变种：http://oj.leetcode.com/problems/search-in-rotated-sorted-array-ii/

简单数学：
http://oj.leetcode.com/problems/pascals-triangle/
http://oj.leetcode.com/problems/pascals-triangle-ii/
http://oj.leetcode.com/problems/powx-n/
http://oj.leetcode.com/problems/reverse-integer/
http://oj.leetcode.com/problems/plus-one/
http://oj.leetcode.com/problems/unique-paths/
http://oj.leetcode.com/problems/palindrome-number/
http://oj.leetcode.com/problems/permutation-sequence/
http://oj.leetcode.com/problems/merge-intervals/
http://oj.leetcode.com/problems/valid-number/
http://oj.leetcode.com/problems/climbing-stairs/
http://oj.leetcode.com/problems/roman-to-integer/
http://oj.leetcode.com/problems/integer-to-roman/
http://oj.leetcode.com/problems/divide-two-integers/
区间：http://oj.leetcode.com/problems/insert-interval/

大数的数学运算：
http://oj.leetcode.com/problems/add-binary/
http://oj.leetcode.com/problems/add-two-numbers/

数组：
http://oj.leetcode.com/problems/remove-element/
http://oj.leetcode.com/problems/merge-sorted-array/
http://oj.leetcode.com/problems/first-missing-positive/
http://oj.leetcode.com/problems/spiral-matrix/
http://oj.leetcode.com/problems/spiral-matrix-ii/
http://oj.leetcode.com/problems/rotate-image/
遍历技巧：http://oj.leetcode.com/problems/container-with-most-water/
http://oj.leetcode.com/problems/two-sum/
http://oj.leetcode.com/problems/3sum/
http://oj.leetcode.com/problems/3sum-closest/
http://oj.leetcode.com/problems/4sum/
http://oj.leetcode.com/problems/set-matrix-zeroes/
用好标记数组：http://oj.leetcode.com/problems/valid-sudoku/
http://oj.leetcode.com/problems/next-permutation/
http://oj.leetcode.com/problems/word-search/
http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/
http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
http://oj.leetcode.com/problems/sort-colors/

暴力方法/细节实现：
http://oj.leetcode.com/problems/max-points-on-a-line/

链表：
归并排序：http://oj.leetcode.com/problems/sort-list/
插入排序：http://oj.leetcode.com/problems/insertion-sort-list/
反转、插入：http://oj.leetcode.com/problems/reorder-list/
检测是否有环：http://oj.leetcode.com/problems/linked-list-cycle/
确定链表环的起点：http://oj.leetcode.com/problems/linked-list-cycle-ii/
Deep Copy 带有随机指针的链表：http://oj.leetcode.com/problems/copy-list-with-random-pointer/
链表细节：http://oj.leetcode.com/problems/rotate-list/
http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/
删除细节：http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list-ii/
http://oj.leetcode.com/problems/partition-list/
http://oj.leetcode.com/problems/swap-nodes-in-pairs/
Merge 两个链表：http://oj.leetcode.com/problems/merge-two-sorted-lists/
Merge 多链表：http://oj.leetcode.com/problems/merge-k-sorted-lists/
细节：http://oj.leetcode.com/problems/reverse-nodes-in-k-group/
http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/
http://oj.leetcode.com/problems/reverse-linked-list-ii/

二叉树遍历：递归 & 非递归
http://oj.leetcode.com/problems/same-tree/
前序：http://oj.leetcode.com/problems/binary-tree-preorder-traversal/
中序：http://oj.leetcode.com/problems/binary-tree-inorder-traversal/
后序：http://oj.leetcode.com/problems/binary-tree-postorder-traversal/
遍历变种：http://oj.leetcode.com/problems/sum-root-to-leaf-numbers/
遍历变种：http://oj.leetcode.com/problems/path-sum/
遍历变种：http://oj.leetcode.com/problems/path-sum-ii/
遍历变种：http://oj.leetcode.com/problems/maximum-depth-of-binary-tree/
遍历变种：http://oj.leetcode.com/problems/minimum-depth-of-binary-tree/
重建二叉树：http://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
重建二叉树：http://oj.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
层次遍历变种：http://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/
遍历变种：http://oj.leetcode.com/problems/symmetric-tree/
遍历应用：http://oj.leetcode.com/problems/binary-tree-maximum-path-sum/
遍历应用：http://oj.leetcode.com/problems/balanced-binary-tree/
遍历应用：http://oj.leetcode.com/problems/recover-binary-search-tree/
遍历应用：http://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/
level遍历：http://oj.leetcode.com/problems/binary-tree-level-order-traversal/
level 遍历：http://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/
level 遍历变种：http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node/
level 遍历变种：http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/

问题分析/智商/细节：
http://oj.leetcode.com/problems/single-number/
http://oj.leetcode.com/problems/single-number-ii/
http://oj.leetcode.com/problems/candy/   ？
http://oj.leetcode.com/problems/gas-station/

动态规划：
http://oj.leetcode.com/problems/triangle/  （最短路径）
http://oj.leetcode.com/problems/subsets/ （另一种形式）
http://oj.leetcode.com/problems/subsets-ii/
http://oj.leetcode.com/problems/edit-distance/ （经典）
http://oj.leetcode.com/problems/word-break/
http://oj.leetcode.com/problems/word-break-ii/
http://oj.leetcode.com/problems/unique-binary-search-trees/  （动态规划避免递归）
http://oj.leetcode.com/problems/unique-paths-ii/
http://oj.leetcode.com/problems/scramble-string/
http://oj.leetcode.com/problems/palindrome-partitioning/
http://oj.leetcode.com/problems/palindrome-partitioning-ii/
http://oj.leetcode.com/problems/interleaving-string/
http://oj.leetcode.com/problems/distinct-subsequences/
http://oj.leetcode.com/problems/decode-ways/
http://oj.leetcode.com/problems/gray-code/
http://oj.leetcode.com/problems/minimum-path-sum/

回溯：
http://oj.leetcode.com/problems/combinations/
http://oj.leetcode.com/problems/generate-parentheses/
http://oj.leetcode.com/problems/combination-sum/
http://oj.leetcode.com/problems/combination-sum-ii/
http://oj.leetcode.com/problems/sudoku-solver/
经典N皇后：http://oj.leetcode.com/problems/n-queens/
http://oj.leetcode.com/problems/n-queens-ii/
http://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/

贪心：
http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/
http://oj.leetcode.com/problems/jump-game/
http://oj.leetcode.com/problems/jump-game-ii/
http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/
http://oj.leetcode.com/problems/maximum-subarray/
http://oj.leetcode.com/problems/minimum-window-substring/
http://oj.leetcode.com/problems/maximal-rectangle/
http://oj.leetcode.com/problems/longest-substring-without-repeating-characters/

分治 & 递归：
http://oj.leetcode.com/problems/unique-binary-search-trees-ii/
http://oj.leetcode.com/problems/restore-ip-addresses/  （时间复杂度有限，递归满足）
http://oj.leetcode.com/problems/permutations/
http://oj.leetcode.com/problems/permutations-ii/
http://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
http://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/
http://oj.leetcode.com/problems/median-of-two-sorted-arrays/
http://oj.leetcode.com/problems/validate-binary-search-tree/

字符串：
http://oj.leetcode.com/problems/count-and-say/
http://oj.leetcode.com/problems/implement-strstr/  （子串查找）
http://oj.leetcode.com/problems/anagrams/
http://oj.leetcode.com/problems/text-justification/ (细节）
http://oj.leetcode.com/problems/simplify-path/  （基础控制语句 if-else-for）
http://oj.leetcode.com/problems/multiply-strings/
http://oj.leetcode.com/problems/regular-expression-matching/
http://oj.leetcode.com/problems/wildcard-matching/
http://oj.leetcode.com/problems/longest-palindromic-substring/
http://oj.leetcode.com/problems/zigzag-conversion/
http://oj.leetcode.com/problems/length-of-last-word/
http://oj.leetcode.com/problems/valid-palindrome/

图：
深搜/广搜：http://oj.leetcode.com/problems/clone-graph/

搜索 & 遍历：
http://oj.leetcode.com/problems/word-ladder/
http://oj.leetcode.com/problems/word-ladder-ii/
广搜：http://oj.leetcode.com/problems/surrounded-regions/
  
喜欢
推荐 33
回应 推荐 喜欢
秋风狂扫
2014-08-21 07:26:03 秋风狂扫

牛逼，很实用！
tianzhaixing
2014-09-02 20:20:53 tianzhaixing

( ^_^ )不错嘛
那个骑士肉肉
2014-11-19 19:43:50 那个骑士肉肉 (一路遇见 一路失散)

：）以后可以发给别人参考一下了
阿恺
2014-11-19 22:18:49 阿恺 (努力的方向：可以依靠，值得信赖)

mark
loop9
2014-12-08 09:43:12 loop9 (Be Professional)

subsets类不应该是属于dfs吗？
马孔多
2014-12-08 10:57:41 马孔多 (Cedar 直待凌云始道高)
subsets类不应该是属于dfs吗？ loop9

也可以。我觉得动规解更简单，https://github.com/ghostrong/leetcode/blob/master/c%2B%2B/subsets.cpp
训训
2015-01-06 22:21:40 训训

mark
范范宽宽
2015-01-28 19:56:41 范范宽宽

mark
Who am I
2015-03-23 22:29:04 Who am I

http://www.makuiyu.cn/leetcode.html
Universe
2015-03-24 08:58:25 Universe

mark
reking
2015-04-04 06:07:08 reking

mark
cici920
2015-04-27 17:47:25 cici920 (different)

mark
2php
2015-10-20 20:16:55 2php

干货啊~~~~~
Seven
2015-10-29 10:48:26 Seven

对我这种英文水平捉急的人来说, 还是看中文的好点
http://tianmaying.com/tutorials/tag/Leetcode
milanlx17
2016-01-08 16:04:56 milanlx17 (take it easy)

mark
zhaichen
2016-02-28 21:42:55 zhaichen

大赞

> 我来回应
马孔多
马孔多 (北京)

Data Mining
马孔多的最新日记  · · · · · ·  ( 全部 )

    请大家支持同胞发起的白宫请愿，把H1B申请作弊者们赶走
    Python小工具 - 下载豆瓣节目里的歌曲  (28人喜欢)
    如何阅读学术论文  (84人喜欢)
    分享我的Leetcode 代码
    找工作总结 - 2014校招季  (44人喜欢)

这篇日记的标签  · · · · · ·
leetcode 编程 算法
推荐这篇日记的豆列  · · · · · ·  ( 全部 )

    douban优秀文章  (181人关注)
    技术！
    好的
    在豆瓣学算法  (39人关注)
    it  (3人关注)






Dynamic Programming

Edit Distance
Maximum Subarray
Minimum Path Sum
Unique Paths
Unique Paths II
Longest Palindromic Substring
Interleaving String
Triangle
Distinct Subsequences
Decode Ways
Palindrome Partitioning II
Maximal Rectangle

Recursion

N-Queens
N-Queens II
Balanced Binary Tree
Binary Tree Inorder Traversal
Binary Tree Maximum Path Sum
Convert Sorted Array to Binary Search Tree
Convert Sorted List to Binary Search Tree
Flatten Binary Tree to Linked List
Maximum Depth of Binary Tree
Minimum Depth of Binary Tree
Path Sum
Permutations
Permutations II
Populating Next Right Pointers in Each Node
Pow(x, n)
Same Tree
Subsets
Sum Root to Leaf Numbers
Swap Nodes in Pairs
Symmetric Tree
Valid Palindrome
Validate Binary Search Tree
Restore IP Addresses
Combinations
Interleaving String (dp is the best)
Combination Sum II
Letter Combinations of a Phone Numbers
Word Search
Construct Binary Tree from Inorder and Postorder Traversal
Construct Binary Tree from Preorder and Inorder Traversal
Generate Parentheses
Surrounded Regions (runtime error)
Palindrome Partitioning
Combination Sum
Sudoku Solver
Unique Binary Search Trees II

Binary Search

Search Insert Position
Search a 2D Matrix
Search for a Range
Search in Rotated Sorted Array
Sqrt(x)

Sequence

Container With Most Water
Count and Say
First Missing Positive
Implement strStr()
Jump Game
Jump Game II
Length of Last Word
Longest Common Prefix
Longest Substring Without Repeating Characters
Merge Sorted Array
Palindrome Number
Plus One
Remove Duplicates from Sorted Array
Remove Duplicates from Sorted Array II
Remove Element
Reverse Integer
Search in Rotated Sorted Array II
Sort Colors
Two Sum
3Sum
3Sum Closest
4Sum
Add Binary
Longest Palindromic Substring
Next Permutation
Longest Valid Parentheses
Climbing Stairs
Permutation Sequence
Simplify Path
String to Integer (atoi)
Minimum Window Substring
Longest Consecutive Sequence
Trapping Rain Water
Valid Number

Linked List

Add Two Numbers
Convert Sorted List to Binary Search Tree
Merge Two Sorted Lists
Partition List
Remove Duplicates from Sorted List
Remove Duplicates from Sorted List II
Remove Nth Node From End of List
Reverse Linked List II
Reverse Nodes in k-Group
Rotate List
Swap Nodes in Pairs

Stack

Binary Tree Inorder Traversal
Binary Tree Level Order Traversal II
Valid Parentheses

Queue

Binary Tree Level Order Traversal
Binary Tree Level Order Traversal II
Populating Next Right Pointers in Each Node II
Symmetric Tree
Surrounded Regions
Word Ladder

Tree

Balanced Binary Tree
Binary Tree Inorder Traversal
Binary Tree Level Order Traversal
Binary Tree Level Order Traversal II
Binary Tree Maximum Path Sum
Convert Sorted Array to Binary Search Tree
Convert Sorted List to Binary Search Tree
Flatten Binary Tree to Linked List
Maximum Depth of Binary Tree
Minimum Depth of Binary Tree
Path Sum
Same Tree
Sum Root to Leaf Numbers
Symmetric Tree
Validate Binary Search Tree


LeetCode 整理：按难度和类型分类排序（146 / 152）
Posted on 2013/12/26	

=== 十月十五日更 ===

题已刷完，这篇总结还落下不少进度。这个网站本属于个人博客，以后我不想把刷题这种纯找工作的文章发在这里。另外，我回头审视了以前写的一些题解，发现还有不少提升空间，包括对解法的描述和代码的优化。因此我重新做了一个题解网站，也希望能以更加清晰的分类目录和解法帮助读者提升刷题的效率，早点从刷题中走出来，做些更有意思的事。鉴于我需要重新描述大多数题目的解法，新的网站目前只有十来道题，我准备在完成全部题解后再尝试推广，大约在十一月下旬完成。完成后会把这里的题解全部删除。

本篇至此停更。

===

Degree of difficulty from 1~5, 1 is the simplest, 5 is the most difficult.

shuashua
分类有点散漫，有些是交叉的，目前有 General, String, Linked List (LL), Array, Tree, Recursion, Dynamic Programming (DP), Bit Manipulation (Bit). 分类标签在标题后的括号里，也有些只出现一两次的标签。
我会把值得复习的题发出来，链接在相应标题上，没链接的题一般比较简单，或者是我认为不太有用的题。

有一点需要注意，我刚开始做题时觉得多数题偏难，随着熟练度提升，有些题对我变简单了，但我还是会按照最开始的难度标准来分类。
这里有一篇文章可供参考编程面试的10大算法概念

1
1.1 Remove Duplicates from Sorted List (LL)
1.2 Remove Element (Array)
1.3 Reverse Integer (General)
1.4 Evaluate Reverse Polish Notation (General)
1.5 Binary Tree Level Order Traversal (Tree)- BFS, use one queue (use its current size)
1.6 Populating Next Right Pointers in Each Node (Tree)- BFS
1.7 Populating Next Right Pointers in Each Node II (Tree) – BFS, use two queues, also solve the 1st version
1.8 Validate Binary Search Tree (Tree) – Think about BST features, it’s easy, use in-order traversal
1.9 Binary Tree Level Order Traversal II (Tree) – Same as the first version.
1.10 Add Binary (Bit)
1.11 Length of Last Word (String) – Way easier than I thought.
1.12 Longest Common Prefix (String) – Avoid being verbose.

2
2.1 Binary Tree Preorder Traversal (Tree)
2.2 Integer to Roman – 这题应该不太会考，没啥意思，我们这种老外哪懂罗马数字的书写规则啊 – –
2.3 Roman to Integer – 同上
2.4 Same Tree (Tree, Recursion)
2.5 Search a 2D Matrix (Array) – Binary Search a Matrix, transform 2D coordinates into 1D
2.6 Plus One (Array) – Need to consider some boundary conditions
2.7 Remove duplicates from sorted array (Array) – Try to be not verbose!
2.8 Climbing Stairs (DP)
2.9 Sort Colors (Array)
2.10 Single Number (Bit)
2.11 Pow(x, n) (Recursion) – Naive recursion wouldn’t work, need some modification. DP and recursion both have pros and cons.
2.12 ZigZag Conversion (Array) – Pure math problem…
2.13 Binary Tree Zigzag Level Order Traversal (Tree) – BFS, use Deque as Stack, notice the order to add children nodes
2.14 Unique Binary Search Trees (Recursion, DP) – Recursion or DP (better)
2.15 Binary Tree Inorder Traversal (Tree) – Iterative, Stack(recommend using Deque in Java)
2.16 Single Number II (Bit) – Bit operation and binary representation of integer
2.17 Merge Sorted Array (Array) – Change perspective of sorted array, compare and fill element from rear, where there is enough space
2.18 Unique Paths (DP)
2.19 Reorder List (LL) – Slow and fast pointers, reverse list, merge list
2.20 Flatten Binary Tree to Linked List (LL)
2.21 Rotate List (LL)
2.22 Search in Rotated Sorted Array – Directly do two binary search
2.23 Search in Rotated Sorted Array II
2.24 Search Insert Position (Array) – Notice the boundary
2.25 Pascal’s Triangle (General) – Fundamental math
2.26 Binary Tree Maximum Path Sum (Tree, Recursion)
2.27 3Sum Closest (General) – Same as 3Sum
2.28 Minimum Path Sum (DP) – Rolling array solution is a bit hard.
2.29 Partition List (LL) – Use two dummy head, make it clear.
2.30 Container With Most Water (General) – 选了两根线以后就把其他线都忽略就好了。
2.31 Rotate Image – 多种解法，关键是找到元素之间的关系，需要一些记忆。
2.32 Merge Intervals (Array) – 这题虽用的是List，但是和Array没区别
2.33 Remove duplicates from sorted array (Array)- 解法很巧妙，核心代码不应超过五行。
2.34 Sqrt(x) – Pure math.
2.35 Anagrams – 注意 anagrams 的中文意思不是回文数。
2.36 Two Sum – 和 Anagrams 的解法一样。
2.37 Multiply Strings – 先做反转字符串，使得相乘过程更清晰，以空间换取可读性，但复杂度不变。

3
3.1 Add Two Numbers (LL)
3.2 Valid Palindrome (General) – 记一些工具函数
3.3 Best Time to Buy and Sell Stock (DP)
3.4 Best Time to Buy and Sell Stock II (DP)
3.5 Best Time to Buy and Sell Stock III (DP) – 常常复习一下
3.6 Swap Nodes in Pairs (LL) – Traverse a list without considering the head node particularly
3.7 Sum Root to Leaf Numbers (Tree)
3.8 Linked List Cycle (LL)
3.9 Same Tree (Tree, Recursion)
3.10 Path Sum (Tree, Recursion or Iteration (hard) )
3.11 Path Sum II (Tree, Recursion)
3.12 Merge Two Sorted Lists (LL)
3.13 Merge k Sorted Lists (LL) – Straightforward way; merge sort way; priority queue way.
3.14 Insertion Sort List (LL) – Easy to get stuck in the first time
3.15 Subsets (Recursion or Iteration)
3.16 Combinations (Recursion and traceback and DFS)
3.17 Triangle (DP) – Bottom-up approach, typical 1D shrink pattern
3.18 Pascal’s Triangle II (General) – Fundamental math. Bottom-up approach, typical 1D shrink pattern
3.19 Copy List with Random Pointer (LL) – Use shadow list
3.20 Spiral Matrix (General) – Note the edge cases, use four boundaries.
3.21 Subsets II (Recursion) – Almost the same as Subsets. Skip the duplicate elements after remove the last element.
3.22 Longest Valid Parentheses (General) – Use a stack to store ‘(‘ index.
3.23 Remove Duplicates from Sorted List II (LL) – Use a dummy node and a while loop to skip duplicates.
3.24 Unique Paths II (DP)
3.25 Longest Substring Without Repeating Characters (String)
3.26 Set Matrix Zeroes – 答案不太容易想到，但很容易理解，以后 in-place 的题可以考虑存在当前已有的数据结构中，这是个技巧。
3.27 N-Queens (Recursion) – Recursion + Traceback, just like Subsets II problem
3.28 N-Queens II (Recursion) – Same as above.
3.29 Sudoku Solver (Recursion) – Almost the same as above.
3.30 Combination Sum (Recursion) – Same as above.
3.31 Combination Sum II (Recursion) – Same as above.
3.32 Permutations (Recursion) – Same as above.
3.33 Permutations II (Recursion) – Almost the same as I, just add a visited array to avoid repeated access, remember to reset it to 0 when trace back.
3.34 Word Search (Recursion) – Same as above.
3.35 Valid Sudoku (Recursion) – Same as 3.29 Sudoku Solver
3.36 Trapping Rain Water (General)
3.37 Jump Game (General) – 做出来之前不知道这么简单，所以还算难一点，这题不用 DP。
3.38 Jump Game II (General) – 解法容易理解，但不容易想到，多复习。
3.39 First Missing Positive (General) – Constant space implies modifying the original array. 每个正值元素 x 存在 index = x-1 处。
3.40 Largest Rectangle in Histogram (General)
3.41 Decode Ways (DP)
3.42 Simplify Path (General)
3.43 Minimum Window Substring (General)
3.44 Restore IP Addresses (DP + recursion)
3.45 Construct Binary Tree from Preorder and Inorder Traversal (Tree)
3.46 Construct Binary Tree from Inorder and Postorder Traversal (Tree)
3.47 Median of Two Sorted Arrays (Array)
3.48 Gas Station (General)
3.49 Surrounded Regions (BFS)
3.50 Insert Interval

president
The following questions are hard to solve in one shot.

4
4.1 Letter Combinations of a Phone Number (Recursion) – Iterative version would be harder, haven’t done that yet.
4.2 Reverse Linked List II (LL) – Tricky, need more practice on exchanging nodes.
4.3 Convert Sorted List to Binary Search Tree (DP, Tree)
4.4 Interleaving String (Classic DP situation, Recursion has too many duplicate search branches)
4.5 Wildcard Matching (Greedy)
4.6 Maximal Rectangle
4.7 Edit Distance (DP)

5
5.1 Linked List Cycle II (LL) – Kind of brain teaser
5.2 Binary Tree Postorder Traversal (Tree) – Use iteration instead of recursion
5.3 Word Ladder (Tree) – BFS!
5.4 Palindrome Partitioning (Recursion + DP) – DFS + Recursion + DP
5.5 Sort List (Recursion + DP) – Recursion version is relatively trivial, while DP version is pretty hard
5.6 3Sum, 4Sum and k-sum (General) – Hashmap ways to solve 3Sum and 4Sum, also recursive solution to k-sum, pretty concise
5.7 LRU Cache (General) 
